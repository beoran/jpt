#!/usr/local/bin/ruby
#
# Jtag programming tool. A wrapper script to flash and confgure 
# broadcom routers. Written by beoran@gmail.com 2012. 
# This program is so specific that you probably can't use it
# unless your name is ps2chiper, but as far as I'm concerned, it's 
# free for anyone to use under the zlib license.
#


# Modify these as needed!

# Directory where the program jpt is instaled.
JPT_DIR               = '/home/bjorn/src/jpt/'

# Minimum and maximum voltage measured over jtag 
# for the board to be programmable. 
VOLTAGE_MIN           = 3.2
VOLTAGE_MAX           = 3.5

# Serial settings
SERIAL_FILE           = '/dev/ttyUSB0'
SERIAL_BAUD           = 115200
SERIAL_READ_TIMEOUT   = 5

### Should be no need to modify anything under this line.
#########################################################

require 'pty'
require 'expect'

$: << (JPT_DIR + 'lib')

require 'termios'
require 'serial'


BRJTAG    = JPT_DIR + 'bin/brjtag.a'
DATA_DIR  = JPT_DIR + 'data'

# serial: 3 cant-p


class Jpt
  
  # probe command: 
  PROBE_COMMAND = "-probeonly /bypass /cable:2 /waitbrk"
  CFE_COMMAND   = "-flash:cfe /bypass /cable:2 /fc:080 /waitbrk"
  BRJTAG_REPLY  = "Broadcom EJTAG Debrick Utility v2.0.5-hugebird"
  BRJTAG_VOLTS  = %r{Detected target Vref = ([0-9]+\.[0-9]+)V}
  BRJTAG_ENTER  = 
  "Press any <Enter> key to continue... ONCE target board is powered on!"
  BRJTAG_COMPLETE = '*** REQUESTED OPERATION IS COMPLETE ***'
  
  
  # checks the brtag's replies and responds to them
  def check_jtag(jtag_out, jtag_in, jtag_pid)    
    return nil, "Could not spawn brjtag." unless jtag_out
    return nil, "Could not spawn brjtag." unless jtag_in
    return nil, "Could not spawn brjtag." unless jtag_pid
    pid_saved = jtag_pid
    aid = jtag_out.expect(BRJTAG_REPLY)
    # check version reply
    unless aid
      return nil, "Wrong version of brjtag.a, expecting v2.0.5-hugebird" 
    end
    # read voltage reply
    aid = jtag_out.expect(BRJTAG_VOLTS)
    unless aid
      return nil, "Could not read voltage, or negative voltage."
    end
    # check voltage      
    voltage = aid.last.to_f
    if voltage < VOLTAGE_MIN
      return nil, "Voltage too low: #{voltage}."
    end
    if voltage > VOLTAGE_MAX
      return nil, "Voltage too high: #{voltage}."
    end
    aid = jtag_out.expect(BRJTAG_ENTER)
    unless aid
      return nil, "Could not read waiting for enter reply."
    end
    jtag_in.write("\r\n")
    aid = jtag_out.expect(BRJTAG_COMPLETE, 9999999)
    p aid
    unless aid
      return nil, "Operation may have failed?"
    end
    # wait for program to finish, sleep 1 second 
    sleep 1.0
    # Process.kill('INT', pid_saved) if pid_saved > 0
    return voltage, "OK!"
  end  
  
  # Probes the board using brjtag
  def probe_brjtag
    pid_saved = -1
    command = BRJTAG + " " + PROBE_COMMAND
    return nil, "Please run this program as uid root" if Process.uid != 0
    return nil, "Please run this program as euid root" if Process.euid != 0
    PTY.spawn(command) do |jtag_out, jtag_in, jtag_pid|
      return check_jtag(jtag_out, jtag_in, jtag_pid)
    end
    return nil, "This should not happen..."
    rescue 
      return nil, $!.to_s
    ensure 
      Process.kill('INT', pid_saved) if pid_saved > 0
  end
  
  
  # Flashes the CFE boot loader to the board using brjtag.
  def flash_cfe_brjtag
    pid_saved = -1
    command = BRJTAG + " " + CFE_COMMAND
    return nil, "Please run this program as uid root" if Process.uid != 0
    return nil, "Please run this program as euid root" if Process.euid != 0
    PTY.spawn(command) do |jtag_out, jtag_in, jtag_pid|
      return check_jtag(jtag_out, jtag_in, jtag_pid)
    end
    return nil, "This should not happen..."
    rescue 
      return nil, $!.to_s
    ensure 
      Process.kill('INT', pid_saved) if pid_saved > 0
  end
  
  
  # First reply that the CFE should give over serial 
  SERIAL_CFE_REPLY = "CFE version ([0-9\.\-]+)"
  
  # Does the required work over the serial port after flashing 
  # (now just tests)
  def serial_work
    Serial.serial(:filename     => SERIAL_FILE, 
                  :baud         => SERIAL_BAUD,
                  :read_timeout => SERIAL_READ_TIMEOUT) do |serial|
      loop do         
        aid = serial.expect(SERIAL_CFE_REPLY, 10)
        if aid 
          puts "serial expect a line:"
          p aid
        else
          printf(".")
        end
#         if serial.read_ok?
#           buf = serial.read_all
#           puts buf
#         end
      end
   end
  end
  
  
  
  
  
  
  
  
  
  
  def mac_address?(text)
    re = %r{\A[0-9A-Fa-f]{12}\Z}
    return re.match(text)
  end
  
  def do_command(line)
    if match = mac_address?(line)
      puts "Using MAC address: #{line} #{match}"
    else
      puts "Not a MAC address!"
    end
    case line
      when "quit"
        @busy = false
      else
        puts "Unknown command!"
    end
  end
  
  
  def read_line
    # Use readline if we have it
    line = ""
    if (self.class.const_get(:Readline) rescue nil)
      line = Readline.readline rescue ""
    else
      line = readline rescue ""      
    end
    return "" if(!line)
    return line.chomp!
  end
  
  def ask_password
    @asking = true
    while @asking
      puts "JPT Password?"
      # use stty to hide password 
      system "stty -echo"
      line = read_line || ""
      system "stty echo"
      if line.reverse == "l00t" + "n0s4j"
        @asking = false
        puts("OK!")
        puts
      elsif line == "quit"
        @asking = false
        @busy   = false
      else
        puts("NO!")
        puts
      end
    end  
  end  
  
  
  def main
    # change to the data dir because brjtag needs to have CFE.BIN, etc in 
    # it's current directory
    Dir.chdir(DATA_DIR)
    
    puts "Probing board..."
    ok, mesg = probe_brjtag
    if ok 
      puts mesg
      puts "Flashing board..."
      ok, mesg = flash_cfe_brjtag
      if ok 
        puts mesg
      else
        puts "Error flashing board: #{mesg}"
      end
    else
      puts "Error probing board: #{mesg}"
    end
    serial_work
    
    return 0
    trap("SIGINT") { @intr = true ; throw :ctrl_c }
    @intr = false
    catch :ctrl_c do
      if @intr
        puts "Interrupted."
      end
    end
    @busy = true
    ask_password # may change @busy 
    while @busy
      puts "JPT Command?"
      line = read_line
      do_command(line)
      puts "-" * 16
    end
  end

  def self.main
    aid = self.new
    aid.main
  end
end



Jpt.main














