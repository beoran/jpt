#!/usr/local/bin/ruby

require 'pty'
require 'expect'


JPT_DIR       = '/home/bjorn/src/jpt/'
VOLTAGE_MIN   = 3.2
VOLTAGE_MAX   = 3.5


$: << (JPT_DIR + 'lib')

require 'termios'
require 'serial'


BRJTAG = JPT_DIR + 'bin/brjtag.a'






class Jpt
  
  # probe command: 
  PROBE_COMMAND = "-probeonly /bypass /cable:2 /waitbrk /srst"
  BRJTAG_REPLY  = "Broadcom EJTAG Debrick Utility v2.0.5-hugebird"
  BRJTAG_VOLTS  = %r{Detected target Vref = ([0-9]+\.[0-9]+)V}
  BRJTAG_ENTER  = 
  "Press any <Enter> key to continue... ONCE target board is powered on!"
  BRJTAG_COMPLETE = '*** REQUESTED OPERATION IS COMPLETE ***'
  
  def probe_brjtag
    pid_saved = -1
    command = BRJTAG + " " + PROBE_COMMAND
    return nil, "Please run this program as uid root" if Process.uid != 0
    return nil, "Please run this program as euid root" if Process.euid != 0
    PTY.spawn(command) do |jtag_out, jtag_in, jtag_pid|
      return nil, "Could not spawn brjtag." unless jtag_out
      return nil, "Could not spawn brjtag." unless jtag_in
      return nil, "Could not spawn brjtag." unless jtag_pid
      pid_saved = jtag_pid
      aid = jtag_out.expect(BRJTAG_REPLY)
      # check version reply
      unless aid
        return nil, "Wrong version of brjtag.a, expecting v2.0.5-hugebird" 
      end
      # read voltage reply
      aid = jtag_out.expect(BRJTAG_VOLTS)
      unless aid
        return nil, "Could not read voltage, or negative voltage."
      end
      # check voltage      
      voltage = aid.last.to_f
      if voltage < VOLTAGE_MIN
        return nil, "Voltage too low."
      end
      if voltage > VOLTAGE_MAX
        return nil, "Voltage too high."
      end
      aid = jtag_out.expect(BRJTAG_ENTER)
      unless aid
        return nil, "Could not read waiting for enter reply."
      end
      jtag_in.write("\r\n")
      
      aid = jtag_out.expect(BRJTAG_COMPLETE, 9999999)
      unless aid
        return nil, "Operation may have failed?"
      end
      Process.kill('INT', pid_saved) if pid_saved > 0
      return voltage, "Probe OK!"
    end
    return true
    rescue 
      return nil, $!.to_s
    ensure 
      Process.kill('INT', pid_saved) if pid_saved > 0
  end
  
  
  
  
  
  
  
  
  def mac_address?(text)
    re = %r{\A[0-9A-Fa-f]{12}\Z}
    return re.match(text)
  end
  
  def do_command(line)
    if match = mac_address?(line)
      puts "Using MAC address: #{line} #{match}"
    else
      puts "Not a MAC address!"
    end
    case line
      when "quit"
        @busy = false
      else
        puts "Unknown command!"
    end
  end
  
  
  def read_line
    # Use readline if we have it
    line = ""
    if (self.class.const_get(:Readline) rescue nil)
      line = Readline.readline rescue ""
    else
      line = readline rescue ""      
    end
    return "" if(!line)
    return line.chomp!
  end
  
  def ask_password
    @asking = true
    while @asking
      puts "JPT Password?"
      # use stty to hide password 
      system "stty -echo"
      line = read_line || ""
      system "stty echo"
      if line.reverse == "l00t" + "n0s4j"
        @asking = false
        puts("OK!")
        puts
      elsif line == "quit"
        @asking = false
        @busy   = false
      else
        puts("NO!")
        puts
      end
    end  
  end  
  
  
  def main
    puts "Probing board..."
    ok, mesg = probe_brjtag
    if ok 
      puts mesg
    else   
      puts "Error probing board: #{mesg}"
    end
    return 0
    trap("SIGINT") { @intr = true ; throw :ctrl_c }
    @intr = false
    catch :ctrl_c do
      if @intr
        puts "Interrupted."
      end
    end
    @busy = true
    ask_password # may change @busy 
    while @busy
      puts "JPT Command?"
      line = read_line
      do_command(line)
      puts "-" * 16
    end
  end

  def self.main
    aid = self.new
    aid.main
  end
end



Jpt.main














